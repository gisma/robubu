% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/makeFlightPlan.R
\name{makeFlightPlan}
\alias{makeFlightPlan}
\title{Tool to generate autonomous flight plans focussing an optimal picture retrieval for DSM/DEM and orthophoto generation}
\usage{
makeFlightPlan(projectDir = "~", missionName = "autoflightcontrol",
  surveyArea = NULL, launchAltitude = -9999, followSurface = FALSE,
  demFn = NULL, altFilter = 1, flightPlanMode = "track",
  flightAltitude = 100, presetFlightTask = "remote", curvesize = 0,
  rotationdir = 0, gimbalmode = 0, gimbalpitchangle = -90,
  overlap = 0.7, uavViewDir = 0, maxSpeed = 20, picRate = 2,
  heatMap = FALSE, picFootprint = TRUE, followSurfaceRes = -9999,
  maxFL = 10, batteryTime = 20, windCondition = 1, rcRange = -9999,
  uavType = "solo", startLitchi = FALSE, actiontype = NULL,
  actionparam = NULL)
}
\arguments{
\item{projectDir}{path to the main folder where several projects can be hosted}

\item{missionName}{base string for mission filenames}

\item{surveyArea}{you may provide either the coordinates by 
c(lon1,lat1,lon2,lat2,lon3,lat3,launchLat,launchLon) or
an OGR compatible file (preferably geoJSON or KML) with
at least 4 coordinates that describe the flight area. 
The fourth coordinate is the launch position.
 You will find further explanation under the \link{seealso}.}

\item{launchAltitude}{absolute altitude of launching position. 
It will overwrite the DEM based estimation if any other value than -9999}

\item{followSurface}{\code{boolean}  TRUE performs an altitude correction 
of the missions flight altitude using additional DEM data. 
If no DEM data is provided and \code{followSurface} is TRUE, 
SRTM data will be downloaded and used
Further explanation at \link{seealso}}

\item{demFn}{filname of the corresponding DEM data file}

\item{altFilter}{if \code{followingTerrain} is equal \code{TRUE} then 
\code{altFilter} is the treshold value of accepted altitude difference bewteen two waypoints in meter.
 If this value is not exceeded the waypoint is omitted due to the fact that only 99 waypoints per mission are allowed.}

\item{flightPlanMode}{type of flightplan. Available are: \code{"waypoints"}, 
\code{"track"}, \code{"manual"}.}

\item{flightAltitude}{set the default flight altitude of the mission. It is 
assumed that the UAV is started at the highest point of the surveyArea 
otherwise you have to defined the position of launching.}

\item{presetFlightTask}{(DJI only) strongly recommended to use "remote" 
       \cr
 Options are: 
\code{"simple_ortho"} takes one picture/waypoint, 
\code{"multi_ortho"} takes 4 picture at a waypoint, two vertically down and two in forward and backward viewing direction and an angele of -60deg,
\code{"simple_pano"} takes a 360 deg panorama picture and 
\code{"remote"} which assumes that the camera is controlled by the remote control (RC)}

\item{curvesize}{(DJI only) controls the curve angle of the uav passing waypoints. 
By default it is set to (\code{= 0.0}). If set to \code{-99} it will be 
calculated from the swath width of the pictures. NOTE This makes only sense for 
\code{followingTerrain = TRUE} to smooth curves.
For \code{flightPlanMode = "waypoint"} camera actions are DISABLED during curve flights.}

\item{rotationdir}{(DJI only) camera control parameter set the UAV basic turn direction to right (0) or left (1)}

\item{gimbalmode}{(DJI only) camera control parameter
\code{0} deactivates the gimbal control
\code{1} activates the gimbale for focussing POIs
\code{2} activates the gimbale for focus and interpolate a field of view in an angel of \code{gimbalpitchangle}}

\item{gimbalpitchangle}{(DJI only) vertical angle of camera  \code{+30 deg..-90 deg}}

\item{overlap}{overlapping of the pictures in percent (1.0 = 100)}

\item{uavViewDir}{viewing directon of camera default is \code{0}}

\item{maxSpeed}{cruising speed}

\item{picRate}{fastest stable interval (s) for shooting pictures}

\item{heatMap}{switch for calculating the overlapping factor on a raster map}

\item{picFootprint}{switch for calculating the footprint at all waypoints}

\item{followSurfaceRes}{horizontal step distance for analysing the DEM altitudes}

\item{batteryTime}{estimated life time of battery}

\item{windCondition}{1= calm 2= light air 1-5km/h, 3= light breeze 6-11km/h, 4=gentle breeze 12-19km/h 5= moderate breeze 20-28km/h}

\item{rcRange}{range of estimated range of remote control}

\item{uavType}{type of uav. currently "djip3" and "solo" are supported}

\item{startLitchi}{if TRUE it starts an offline Litchi website for converting the data (preliminary workaround)}

\item{actiontype}{(DJI only) individual actionype settings of the camera c(1,1,...)}

\item{actionparam}{(DJI only) corresponding parameter for the above individual actiontype c(0,0,...)}

\item{workingDir}{actual project working folder is always a subdirectory of \code{projectDir}}

\item{batteryTime}{user defined estimation of the lipo lifetime (20 min default)}
}
\description{
makeFlightPlan creates intermediate flight control files for the dji
  phantom x UAVs and ready to use control files for the 3DR Solo. It is designed either for the propietary \code{litchi} flight 
  control app exchange format as well as for the MAVLINK common message set that is used by the PixHawk flight controller family. \cr\cr
  DJI:\cr
  The reason using litchi for controlling dji uavs is because lichti provides additionally to a 
  cloud based mission planer an offline/standalone interface to import a csv formated waypoint file. \cr\cr
  PixHawk/3DR Solo:\cr
  The open uav community is focussed on the PixHawk autopilot unit and the Mission Planner software. 
  It is well documented and serveral APIs are provided. Nevertheless a terrain following autonomous flight planning tool is 
  not available. In a first rough implementation the  MAV format is generated and can easily pushed on the uav 
  using the \code{upload2Solo} function.
}
\note{
There are still a lot of construction zones around. This script is far beyond to be in a mature state. So again control everything at least twice.
}
\section{Warning}{

 Take care! Please control and backup all controls again while planning and performing autonomous flight plans and missions.
 You will have a lot of chances to make a small mistake what may yoild in a damage of your uav 
 or even worse in involving people, animals or non-cash assets. AVOID any risk!
}

\section{Basic Introduction}{
 
\subsection{Survey Area}{

  To define a flight area you have to provide either 4 Points (or 3 lines). 
  You may take more complex vectors like a multi point polygon,
  but only the first 4 coordinates x1, x2, x3 and x4 (for the launching position) 
  are used in exactly this order. 
  If you take a rectangle the 4th corner coordinate will be the launching point!
  \cr\cr
  The concept is looking like the following sketch.
 \preformatted{ 
  x2------x3           x2-------x1
  | a                 /
  |                  /
  |   x4            / x4    
  |  /             / /
  x1/             x3/
  }
  This coordinates the length of the line and the angle are used to calculate extend and paralells 
  of the flightplan according to the flight altitude, overlap etc. Note the flight direction depends on 
  the order of the points. If the \code{flightPlanMode} is equal \code{tracks}.
  \cr\cr
  The result look like this.
  
 \preformatted{ 
 
  #--#  #-->             #--#  #
  |  |  |               /  /  /
  |  |  |              /  /  /
  |  |  |             /  /  / 
  #  #--#         <--#  #--#
  }
 If \code{flightPlanMode} is equal \code{waypoints} the result is an equal spatial distribution of waypoints:
 \preformatted{ 
 
  #--#  #-->             #--#  #
  |  |  |               /  /  /
  #  #  #              #  #  #
  |  |  |             /  /  / 
  #  #--#         <--#  #--#
  
  }
  
 
  \code{waypoints} is optimal for autonoumous flights under calm conditions in complex terrain 
  because the camara takes a picture at every waypoint\cr
  \code{track} is optimal for relatively plain areas and automatically triggered picture capturing
  Note: Automatically picture capturing in a time interval works only within the range of the remote control. 
  because the the uav needs a trigger signal for taking pictures.
  }
  \subsection{Terrain Following flightplan}{
  
  The \code{followSurface} switch is used to adapt the fixed flight altitude into a terrain following flight altitude.\cr 
  ----------------------------------------------------------------------------------------------------------\cr
  NOTE: You have to be aware that the DJI uav is calibrating the altitude at the launch position in the field!
  So you need either a correct coordinate altitude or a high resolution DEM to get a good! estimation of the lauch position and altitude. 
  You must choose a clearly defined and reliable launching position both in the map and the field. If you fail I made the experience that the aircraft 
  probably will hit the terrain...\cr
  ----------------------------------------------------------------------------------------------------------\cr\cr

 How it works. Let us assume a defined flightaltitude of 50 m. 
 According to the launching point altitude the uav will act like the following sketch shows:
  
\preformatted{ 
                     
  ............... x_(uav)_x ........... uav started at 30 m altitude results in 
                                           a "real" flight altitude of 30m + 50m => 80m
  
  
                  ___60m____
                 |          | 
         30m _x__|          | 
        ____|               |___  
    ___|                        |____ 
 
  
                 ___60m____
      ..........|          |............ uav started at 0 m altitude results in 
             ___|          |___          "real" flight altitude of 50m above 0m
        ____|                  |  
    ___|                       |__x__ 0m
  }  
 To avoid negative impacts from the P3 auto calibration, the launch altitude is used to
 correct the flight altitude according to: \cr
 maximumAltitude_of_surveyArea + altitude_of_launchposition\cr
 So the adapted flight altitude is always seen as the flight altitude above the highest terrain altitude:
  \preformatted{
                 
 ...................................... real altitude of uav 110 m
         

                 ___60m____ 
                |          |
         30m _x_|          |___
        ____|                  |  
    ___|                       |______ 
  }  
 To get a fixed scale flight the launch altitude is used to correct the flight altitude according to   maximumAltitude of surveyArea + altitude of launchposition. With the setting auf terrainfoollowing = true tis is calculated for each waypoint.  . So the adapted flight altitude looks like:
  \preformatted{
                 
                 ..........
                |          |
            ....|          |.... 
       ....|     ___60m____    |    
  ....|         |          |   |....... real altitude of uav 50m
         30m _x_|          |___
        ____|                  |  
    ___|                       |___x___ 0m
  }  
  }
}
\examples{

\dontrun{
# Please keep in mind that there is a bunch of interdependent parameter settings.

# The following spatial data sets are returned   

# fpdata[[1]]    the planned launching position of the uav. 
# fpdata[[2]]    waypoints inclusive all informations
# fpdata[[3]]    the digitial elevation model (DEM)
# fpdata[[4]]    optimized footprints(fov) of the camera
# fpdata[[5]]    flight area with at least 2 overlaps
# fpdata[[6]]    estimated area covered by the RC according to the range and line of sight 
# fpdata[[7]]    a heatmap abundance of pictures/pixel (VERY SLOW, only if heatMap = TRUE)

## (1) simple flight, 50 meters above ground 
## assuming a flat topography,
## generating a heatmap to estimate overlapping

fpdata<-makeFlightPlan(surveyArea=c(50.80801,8.72993,50.80590,8.731153,50.80553,8.73472,50.8055,8.734),
                        heatMap=TRUE)
                        
## view results

mapview(fpdata[[1]],color="red",cex=5)+
mapview(fpdata[[2]],zcol = "altitude",lwd=1,cex=4)+
mapview(fpdata[[3]])+
mapview(fpdata[[4]],color="darkblue", alpha.regions = 0.1,lwd=0.5)+
mapview(fpdata[[5]],color="red", alpha.regions = 0.1,lwd=1.0)+
mapview(fpdata[[6]]+
mapview(fpdata[[7]]


## (2) adapting viewing angle of the camera, 
##     adding coverage map, switching to track mode

fpdata<-makeFlightPlan(surveyArea=c(50.80801,8.72993,50.80590,8.731153,50.80553,8.73472,50.80709,8.734),
                   uavViewDir=30,
                   flightPlanMode="track",
                   heatMap=TRUE)
           
## view results                          

mapview(fpdata[[4]],color="darkblue", alpha.regions = 0.1,lwd=0.5)+
mapview(fpdata[[5]],color="red", alpha.regions = 0.1,lwd=1.0)


## (3) Increase overlapping

fpdata<-makeFlightPlan(surveyArea=c(50.80801,8.72993,50.80590,8.731153,50.80553,8.73472,50.80709,8.734),
                   overlap=0.8,
                   uavViewDir=30,
                   flightPlanMode="track",
                   heatMap=TRUE)
                   
## view results    
              
mapview(fpdata[[4]],color="darkblue", alpha.regions = 0.1,lwd=0.5)+
mapview(fpdata[[5]],color="red", alpha.regions = 0.1,lwd=1.0)+
mapview(fpdata[[7]] 


## (4) terrain following flightplan
##     add DEM

fpdata<-makeFlightPlan(surveyArea = c(50.80801,8.72993,50.80590,8.731153,50.80553,8.73472,50.80709,8.734), 
                   followSurface = TRUE,
                   demFn = "inst/data/mrbiko.tif",
                   )
                        
## view results

mapview(fpdata[[1]],color="red",cex=5)+
mapview(fpdata[[2]],zcol = "altitude",lwd=1,cex=4)+
mapview(fpdata[[3]])+
mapview(fpdata[[4]],color="darkblue", alpha.regions = 0.1,lwd=0.5)+
mapview(fpdata[[5]],color="red", alpha.regions = 0.1,lwd=1.0)+
mapview(fpdata[[6]]

  
## (5) lowering flight altitude check resulting parameters 
## TAKE CARE!

fpdata<-makeFlightPlan(surveyArea=c(50.80801,8.72993,50.80590,8.731153,50.80553,8.73472,50.8055,8.734), 
                   followSurface = TRUE, 
                   flightAltitude = 25, 
                   demFn = "inst/data/mrbiko.tif")
                        
## view results

mapview(fpdata[[1]],color="red",cex=5)+
mapview(fpdata[[2]],zcol = "altitude",lwd=1,cex=4)+
mapview(fpdata[[3]])+
mapview(fpdata[[4]],color="darkblue", alpha.regions = 0.1,lwd=0.5)+
mapview(fpdata[[5]],color="red", alpha.regions = 0.1,lwd=1.0)+
mapview(fpdata[[6]]+

 
## (6) use of external vector data to define the surveyArea...
##     digitize flight area using leafDraw()
##     save vectors as JS "json" or "kml" files
##     provide full filename+upper extensions!

leafDraw(preset="uav")

## assuming resulting file is named "uav.json"
## use it for planning

fpdata<-makeFlightPlan(projectDir="~/proj",
                   workingDir="/uav/test",
                   missionName = "test",
                   surveyArea="~/uav.json", 
                   followSurface = TRUE, 
                   flightAltitude = 50,
                   overlap = 0.7,
                   demFn = "inst/data/mrbiko.tif",
                   altFilter = 3.5,
                   maxSpeed = 65,
                   windCondition = 1)
                        
## view results
                    
 mapview(fpdata[[5]],color="red", alpha.regions = 0.1,lwd=0.5)+
 mapview(fpdata[[1]],zcol = "altitude",lwd=1,cex=4)+
 mapview(fpdata[[3]],color="red",cex=5)+
 mapview(fpdata[[6]],alpha.regions = 0.2)
}
}
\author{
Chris Reudenbach
}

